/*******************************************************************************
 * Assurance Contract Annex Plugin for OSATE
 * Copyright 2023 Carnegie Mellon University.
 * NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE 
 * MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO 
 * WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT 
 * NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR 
 * RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE 
 * ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT 
 * INFRINGEMENT.
 * Released under a BSD (SEI)-style license, please see license.txt or contact 
 * permission@sei.cmu.edu for full terms.
 * [DISTRIBUTION STATEMENT A] This material has been approved for public release and 
 * unlimited distribution.  Please see Copyright notice for non-US Government use and 
 * distribution.
 * Carnegie MellonÂ® is registered in the U.S. Patent and Trademark Office by Carnegie 
 * Mellon University.
 * This Software includes and/or makes use of the following Third-Party Software subject 
 * to its own license:
 * 1. Z3 (https://github.com/Z3Prover/z3/blob/master/LICENSE.txt) Copyright Microsoft 
 * Corporation.
 * 2. Eclipse (https://www.eclipse.org/legal/epl-2.0/) Copyright 2000, 2023 Eclipse 
 * contributors and others.
 * DM23-0575
 *******************************************************************************/

import java.util.Map
import java.util.Optional
import org.eclipse.xsemantics.runtime.RuleEnvironment
import org.eclipse.xtext.EcoreUtil2
import org.osate.sysmlv2.contract.contract.AndExpression
import org.osate.sysmlv2.contract.contract.Expression
import org.osate.sysmlv2.contract.contract.MemberCall
import org.osate.sysmlv2.contract.contract.NameReference
import org.osate.sysmlv2.contract.contract.NotExpression
import org.osate.sysmlv2.contract.contract.OrExpression
import org.osate.sysmlv2.contract.contract.PropertyLookup
import org.osate.sysmlv2.contract.contract.Query
import org.osate.sysmlv2.contract.contract.SelfExpression
import org.osate.sysmlv2.contract.contract.SingleParameter
import org.osate.sysmlv2.contract.contract.SingleValDeclaration
import org.osate.sysmlv2.contract.contract.StringLiteral
import org.osate.sysmlv2.contract.contract.TupleDeclaration
import org.osate.sysmlv2.contract.contract.TupleExpression
import org.osate.sysmlv2.contract.contract.TupleName
import org.osate.sysmlv2.contract.contract.TupleParameter
import org.osate.sysmlv2.contract.tuples.Tuple
import org.omg.sysml.lang.sysml.Element
import org.omg.sysml.lang.sysml.OccurrenceDefinition
import org.osate.sysmlv2.contract.contract.UsageExpression

system org.osate.sysmlv2.contract.typing.ContractInterpreter

inject ContractTypeSystem typeSystem

judgments {
	evaluateQuery ||- Query query ~> output Map<String, Object>
	evaluateExpression |- Expression expression ~> output Object
}

rule EvaluateSingleValDeclaration
	G ||- SingleValDeclaration valDeclaration ~> Map<String, Object> result
from {
	G |- valDeclaration.value ~> var Object value
	result = #{valDeclaration.name -> value}
}

rule EvaluateTupleDeclaration
	G ||- TupleDeclaration tupleDeclaration ~> Map<String, Object> result
from {
	G |- tupleDeclaration.value ~> var Tuple tupleResult
	result = newLinkedHashMap
	for (var i = 0; i < tupleDeclaration.names.size; i++) {
		result.put(tupleDeclaration.names.get(i).name, tupleResult.elements.get(i))
	}
}

rule EvaluateOrExpression
	G |- OrExpression expression ~> Boolean result
from {
	G |- expression.left ~> var Boolean leftValue
	if (leftValue) {
		result = true
	} else {
		G |- expression.right ~> var Boolean rightValue
		result = rightValue
	}
}

rule EvaluateAndExpression
	G |- AndExpression expression ~> Boolean result
from {
	G |- expression.left ~> var Boolean leftValue
	if (leftValue) {
		G |- expression.right ~> var Boolean rightValue
		result = rightValue
	} else {
		result = false
	}
}

rule EvaluateNotExpression
	G |- NotExpression expression ~> Boolean result
from {
	G |- expression.operand ~> var Boolean operandValue
	result = !operandValue
}

rule EvaluateMemberCall
	G |- MemberCall expression ~> Object result
from {
	val leftType = typeSystem.expressionType(expression.left).value
	G |- expression.left ~> var Object leftValue
	result = switch member : leftType.members.get(expression.right) {
		SimpleMember<Object, Object>: member.evaluate(leftValue)
		MemberWithTypeParameter<Object, Object>: {
			val javaType = GenericTypeArgumentRegistry.getJavaType(expression.typeArgument)
			if (javaType !== null) {
				member.evaluate(leftValue, javaType)
			}
		}
		MemberWithArgument<Object, Object, Object>: {
			G |- expression.argument ~> var Object argumentValue
			member.evaluate(leftValue, argumentValue)
		}
		MemberWithLambda<Object, Object, Object>: {
			val lambda = expression.lambda
			val parameter = lambda.parameter
			member.evaluate(leftValue) [element |
				val withParameters = new RuleEnvironment(G)
				switch parameter {
					SingleParameter: withParameters.add(parameter.name, element)
					TupleParameter: {
						val tuple = element as Tuple
						for (var i = 0; i < parameter.names.size; i++) {
							withParameters.add(parameter.names.get(i).name, tuple.elements.get(i))
						}
					}
				}
				withParameters |- lambda.returnValue ~> var Object lambdaResult
				lambdaResult
			]
		}
	}
}

// Need to look up stuff like this: Period = 1000 [micro * s];
rule EvaluatePropertyLookup
	G |- PropertyLookup expression ~> Optional<?> result
from {
	G |- expression.left ~> var Element lookupContext
	result = InterpreterUtils.lookupAttributeValue(lookupContext as OccurrenceDefinition, expression.right)
	// TODO: Fix later
//	try {
//		val value = CodeGenUtil.lookupProperty(expression.right, lookupContext, Optional.^empty)
//		val resolved = CodeGenUtil.resolveNamedValue(value, lookupContext, Optional.^empty)
//		result = Optional.of(TypeSystemUtils.convertPropertyValue(resolved, lookupContext))
//	} catch (PropertyNotPresentException e) {
//		result = Optional.^empty
//	} catch (PropertyDoesNotApplyToHolderException e) {
//		result = Optional.^empty
//	} catch (PropertyIsModalException e) {
//		result = Optional.^empty
//	}
}


//rule EvaluatePropertyLookup
//	G |- PropertyLookup expression ~> Optional<?> result
//from {
//	G |- expression.left ~> var NamedElement lookupContext
//	try {
//		val value = CodeGenUtil.lookupProperty(expression.right, lookupContext, Optional.^empty)
//		val resolved = CodeGenUtil.resolveNamedValue(value, lookupContext, Optional.^empty)
//		result = Optional.of(TypeSystemUtils.convertPropertyValue(resolved, lookupContext))
//	} catch (PropertyNotPresentException e) {
//		result = Optional.^empty
//	} catch (PropertyDoesNotApplyToHolderException e) {
//		result = Optional.^empty
//	} catch (PropertyIsModalException e) {
//		result = Optional.^empty
//	}
//}


axiom EvaluateSelfExpression
	G |- SelfExpression expression ~> env(G, "self", OccurrenceDefinition)

axiom EvaluateStringLiteral
	G |- StringLiteral expression ~> expression.value

rule EvaluateTupleExpression
	G |- TupleExpression expression ~> Tuple result
from {
	val elementResults = newArrayList
	for (element : expression.elements) {
		G |- element ~> var Object elementResult
		elementResults += elementResult
	}
	result = new Tuple(elementResults)
}

axiom EvaluateUsageExpression
	G |- UsageExpression expression ~> expression.usage

rule EvaluateNameReference
	G |- NameReference expression ~> Object result
from {
	val named = expression.reference
	switch named {
		SingleParameter,
		TupleName case named.eContainer instanceof TupleParameter: result = env(G, named.name, Object)
		SingleValDeclaration: {
			G |- named.value ~> result
		}
		TupleName: {
			val tupleDeclaration = EcoreUtil2.getContainerOfType(named, TupleDeclaration)
			G |- tupleDeclaration.value ~> var Tuple tupleResult
			val index = tupleDeclaration.names.indexOf(named)
			result = tupleResult.elements.get(index)
		}
		/*
		 * Special handling for LongWithUnits.scaledTo() and Record.get(), etc. 
		 */
//		UnitLiteral,
//		EnumerationLiteral,
//		BasicProperty: result = named
	}
}